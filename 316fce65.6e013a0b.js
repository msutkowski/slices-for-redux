(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{113:function(e,t,r){"use strict";r.d(t,"a",(function(){return o})),r.d(t,"b",(function(){return u}));var n=r(0),a=r.n(n),c=a.a.createContext({}),i=function(e){var t=a.a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):Object.assign({},t,e)),r},o=function(e){var t=i(e.components);return a.a.createElement(c.Provider,{value:t},e.children)};var s="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},l=Object(n.forwardRef)((function(e,t){var r=e.components,n=e.mdxType,c=e.originalType,o=e.parentName,s=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===t.indexOf(n)&&(r[n]=e[n]);return r}(e,["components","mdxType","originalType","parentName"]),l=i(r),u=n,p=l[o+"."+u]||l[u]||d[u]||c;return r?a.a.createElement(p,Object.assign({},{ref:t},s,{components:r})):a.a.createElement(p,Object.assign({},{ref:t},s))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var c=r.length,i=new Array(c);i[0]=l;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[s]="string"==typeof e?e:n,i[1]=o;for(var u=2;u<c;u++)i[u]=r[u];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,r)}l.displayName="MDXCreateElement"},97:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return i})),r.d(t,"rightToc",(function(){return o})),r.d(t,"metadata",(function(){return s})),r.d(t,"default",(function(){return u}));var n=r(1),a=r(6),c=(r(0),r(113)),i={},o=[{value:"Features",id:"features",children:[{value:"rootReducer",id:"rootreducer",children:[]},{value:"createSlice",id:"createslice",children:[]}]}],s={id:"internal/features",title:"features",description:"Mutable Reducers",source:"@site/docs/internal/features.md",permalink:"/slices-for-redux/docs/internal/features"},d={rightToc:o,metadata:s},l="wrapper";function u(e){var t=e.components,r=Object(a.a)(e,["components"]);return Object(c.b)(l,Object(n.a)({},d,r,{components:t,mdxType:"MDXLayout"}),Object(c.b)("p",null,"Mutable Reducers\nSlice Groups\nOpinionated Slice\nProcedure File"),Object(c.b)("h2",{id:"features"},"Features"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("p",{parentName:"li"},'A "mutable combine root reducer" that enables "slice reducers" to be added as their code is imported, removes code boilerplate and promotes code splitting.')),Object(c.b)("li",{parentName:"ul"},Object(c.b)("p",{parentName:"li"},"A createSliceGroup() function to organize and ease the navigation of a large State object.")),Object(c.b)("li",{parentName:"ul"},Object(c.b)("p",{parentName:"li"},'An opinionated createSlice() function that promotes writing sets of "case reducers" in separate files.')),Object(c.b)("li",{parentName:"ul"},Object(c.b)("p",{parentName:"li"},'A "Procedure File" pattern for writing Redux code that better scales.'))),Object(c.b)("h3",{id:"rootreducer"},"rootReducer"),Object(c.b)("p",null,"Most applications create the rootReducer with ",Object(c.b)("a",Object(n.a)({parentName:"p"},{href:"https://redux.js.org/api/combinereducers"}),Object(c.b)("inlineCode",{parentName:"a"},"combineReducers()"))," from Redux.\nAll slice reducers must be imported and combined when creating the rootReducer.",Object(c.b)("br",{parentName:"p"}),"\n","When code splitting, dynamically loaded modules need a way to add new reducers\nto the rootReducer."),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"Slices for Redux"),"'s ",Object(c.b)("inlineCode",{parentName:"p"},"rootReducer")," is dynamic. Slice reducers are added as needed.\nThis simplifies and promotes code splitting because importing and combining\nreducers at startup can be avoided for the majority of slice reducers.\nSlice Reducers can self add to the rootReducer when their code is loaded\nusing addReducers."),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"rootReducer.addReducers({ [sliceName]: sliceReducer })")),Object(c.b)("p",null,"Only those reducers that are not self adding need to be imported and added at startup.",Object(c.b)("br",{parentName:"p"}),"\n","Less boiler plate code and merge conflicts: there is no longer the need to import and modify the reducers.js file each time a new reducer is written."),Object(c.b)("h3",{id:"createslice"},"createSlice"),Object(c.b)("p",null,"As the application grows and features are added, the code in slice reducers becomes\nlarger and the source of merge conflicts.\nInstead of using a single large switch statement one can use case reducers to handle specific action type."),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"Slices for Redux"),"'s ",Object(c.b)("inlineCode",{parentName:"p"},"createSlice")," promotes writing case reducers in separate files.\nWhen the Slice is created its reducer is empty (has no case reducers).\nThe files that define the case reducers adds those to the slice's reducer using\nthe slice's addCaseReducers function."),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"someSlice.addCaseReducers({ [actionKey]: caseReducer })")),Object(c.b)("p",null,"With ",Object(c.b)("inlineCode",{parentName:"p"},"createSlice")," the slice file no longer needs to contain nor import all the cases reducers. The benefits are a simpler slice file, less prone to merge conflicts and cases reducers defined in separate files which make it easier to scale a maintain a large Redux application."))}u.isMDXComponent=!0}}]);